# Lab 3

This lab should familiarize you with using OpenMP to parallelize code.

## Summary:
In this lab you'll parallelize a sorting algorithm from Lab 0 using OpenMP, *_one of_* either MergeSort or QuickSort.  

## Code Requirements / Restrictions

You need to implement *_one of_* either MergeSort or QuickSort using OpenMP.  For ten percent additional credit, you may implement both.

Your code should leverage the OpenMP library to parallelize code.  You should not use pthreads or C/C++ atomics to manage or synchronize threads.  As with Lab 0, you need to write the sorting code --- you can't use a prewritten sorted data structure.  You are welcome to either reuse or rewrite your implementation from prior labs.  

### Lab write-up:
Your lab write-up, called `WRITEUP.md` should include:
* A comparison between the ease of parallelization between pthreads and OpenMP.
* A discussion of performance between OpenMP and pthread implementations
* A description of your parallelization strategy
* A brief description of your code organization
* A description of every file submitted
* Any extant bugs

I expect your lab write-up for this project will be around a page or two.

### Submission:
You should submit a link to your final commit to the canvas assignment, following the instructions on the class website.  This mechanism allows us to be sure of exactly what commit you intend to be graded, and when you completed it.  Do not forget this step!

### Compilation and Execution:
Your submission should contain a Makefile and the project should build using a single `make` command.  The generated executable should be called `mysort`.  The `mysort` command should have the following syntax  (effectively the same as Lab 1, but with different `--alg` arguments):

`mysort [--name] [source.txt] [-o out.txt] [-t NUMTHREADS]  [--alg=<merge,quick>]`

If the `--alg` argument is not provided, you should use the algorithm you have implemented.  If an algorithm is passed which you have not implemented, (e.g. `--alg=merge` when you wrote quicksort) simply print an error message and exit.

Using the `--name` option should print your name.  Otherwise, the program should sort the source file.  The source file is a text file with a single integer on each line.  The `mysort` command should then sort all integers in the source file and print them sorted one integer per line to an output file (specified by the `-o` option). The time taken to sort the file (excluding the time for file I/O and to initially launch / finally join threads) should be printed to standard out in nanoseconds.  The `-t` option specifies the number of threads that should be used, including the master thread, to accomplish the sorting.  

See below for `mysort` syntax examples.  As before, you can assume that all input values are non-negative, less than or equal to `INT_MAX`, and that there are no duplicates.

### Testing:
We include a `autograde.sh` script and eight test cases, located in `autograde_tests` for you to test your code.  Your submission will be autograded every time you push using the autograder.  To run the autograder on the provided tests, use:

`./autograde.sh`

You can add additional test cases in an additional directory.  You can generate test input files using the UNIX `shuf` (shuffle) command (see below for examples using a bash shell).  Using this input file you can compare your results with `sort` using the `cmp` command, which checks if files are equivalent. To run the autograder on your own directory, use:

`./autograde.sh ./my_own_test_directory`

I _highly_ recommend you test your code using this methodology... it's how we'll grade you!

### Code style:
Your code should be readable and commented so that the grader can understand what's going on.

## Grading:
Your assignment will be graded as follows:
* *Unit tests (80%):*
We will check your code using sixteen randomly generated input files (generated by `shuf` and checked by `cmp`.  Correctly sorting a file is worth five points.  Half of these test cases are in the `autograde_tests` directory.
* *Lab write-up, code readability, and coding interview (20%):* 
Lab write-ups and readable code that meet the requirements will get full marks. Incomplete write-ups or unreadable code will be docked points.
* *Extra credit (10%):*
You may implement both algorithms (mergesort and quicksort) for ten points extra credit. In this case, your unit tests credit will be split equally across 90% of the assignment.

Recall that late submissions will be penalized 5% for every day late, and will not be accepted after the final day of class.

## Examples

Examples of your `mysort` program's syntax
```
### print your name
./mysort --name
# prints:
Your Full Name

### Consider an unsorted file
printf "3\n2\n1\n" > 321.txt
cat 321.txt
# prints
3
2
1

### Sort the text file and print to file
./mysort 321.txt -o out.txt -t5 --alg=forkjoin
# prints time taken in nanoseconds for 5 threads on fork/join sort:
294759

cat out.txt
# prints:
1
2
3
```

Several useful shell commands for this assignment:
```
### To generate a random test file ###
# -i1-10 is the range (1 to 10)
# -n5 is the length (chose 5 numbers from the range)
# testcase.txt is the output shuffled file
shuf -i1-10 -n5 > testcase.txt

### To sort a text file with linux ###
# -n is cast each line to integers
# testcase.txt is the shuffled file
# testsoln.txt is the sorted file
sort -n testcase.txt > testsoln.txt

### To compare two text files ###
# e.g. to verify your program's correctness
# Note that line endings matter!
cmp --silent myoutput.txt testsoln.txt && echo "Same!" || echo "Different!"
```


How we will grade your code:
```
### Generate a test file
### (of unspecified range and size)
shuf -i0-2147483643 -n382 > case1.txt

### Sort it using sort
sort -n case1.txt > soln1.txt

### Run your mysort program to also sort the test file
./mysort case1.txt -o your1.txt --alg=merge

### Compare test results
cmp --silent your1.txt soln1.txt && echo "Pass (5pts)" || echo "Fail (0pts)"
```
